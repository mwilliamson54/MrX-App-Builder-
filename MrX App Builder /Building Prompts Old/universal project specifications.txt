MrX App Builder Platform — UNIVERSAL PROJECT SPECIFICATION (Developer-Friendly Expanded Blueprint)

PURPOSE
The MrX App Builder Platform is a free-first, cloud-coordinated, AI-assisted Android development environment. It enables users to create, iterate, test, and ship Android apps by combining an interactive web dashboard (Cloudflare Pages), a lightweight serverless backend (Cloudflare Pages Functions + Workers KV), and a heavy compute agent running in Google Colab. Source code lives in GitHub, build artifacts (APKs) live in Google Drive. The system enforces retrieval-augmented generation (RAG) and local embedding/vector search (FAISS) to minimize token usage, improve relevance, and remain within free or open-source tooling.

HIGH-LEVEL GOALS
• Provide multi-project, multi-chat conversational workspaces per project (cursor-style).  
• Ensure all heavy compute (embeddings, vector indices, parsing, Gradle builds) runs in Colab.  
• Use only local open-source embedding models and FAISS for vector search.  
• Keep the frontend credential-free — secrets live only in KV or Colab runtime.  
• Keep the system operable on free tiers: Cloudflare Pages (UI + Functions), Workers KV (metadata), GitHub (code), Google Drive (artifacts), Google Colab (compute).

PRIMARY COMPONENTS
1. Dashboard (Cloudflare Pages static site)
2. Backend (Cloudflare Pages Functions — API layer)
3. Workers KV (metadata, logs, chat histories, job queue, encrypted secrets)
4. Colab Heavy Agent (compute host for embeddings, parsing, builds)
5. GitHub (source code storage & version control)
6. Google Drive (APK artifact storage)
7. Local FAISS indices and open-source embedding models (MiniLM-L6, BGE-small/base, MPNet, Instructor-large)
8. Tree-Sitter parsers (Java, Kotlin, XML, Groovy) for structural chunking

PROJECT & CHAT MODEL
• Project: top-level entity mapped to one GitHub repository. Repo naming convention: mrx-{projectName} or org/mrx-{projectName}.  
• Chat: conversational workspace within a project. Each chat supports independent context, messages, and retrieval scope.  
• Multi-chat per project: Each chat has chatId, title, createdAt, lastUpdated, messages[], LLMMode (custom endpoint | openai-key optional), and retrievalFilters (folders, packages, paths).

DATA FLOW (USER → DASHBOARD → BACKEND → COLAB → GITHUB → DRIVE)
1. User action (message, build trigger, patch request) issued in Dashboard UI.
2. Dashboard calls Backend API (auth token limited to user session; no secrets).
3. Backend writes job & message metadata to Workers KV and returns jobId.
4. Colab polls /jobs/claim (or backend pushes a message via webhook) and claims job using a secure ephemeral claim token.
5. Colab pulls repo (git clone or shallow fetch) using GitHub PAT present only in Colab environment.
6. Colab runs Tree-Sitter to chunk source files, generates local embeddings with selected open models, updates FAISS index.
7. Colab performs retrieval, assembles minimal LLM context, issues LLM call (custom LLM preferred; OpenAI optional if user provided key).
8. Colab generates patches, runs unified-diff, commits to a temporary branch, opens PR or pushes branch.
9. Colab triggers Gradle build; upon success uploads APK to Google Drive at MrX App Builder / {ProjectName} / {Summary}.apk and posts artifact metadata to KV.
10. Backend updates job state and notifies Dashboard; Dashboard streams logs and artifacts to user.

FREE-FIRST TOOL SELECTION RATIONALE
• Cloudflare Pages + Functions — free static hosting + serverless endpoints for UI and API.  
• Workers KV — free-tier key-value store for small-scale metadata and logs.  
• GitHub — free for public/private repos (source of truth).  
• Google Drive — free artifact hosting under predictable folder structure.  
• Google Colab — free compute environment for heavy tasks (embeddings, builds).  
• FAISS + local embedding models — avoids paid vector DBs and vendor lock-in.  
• Tree-Sitter — robust syntactic parsing enabling precise chunking.

BRANCH & FILE STRUCTURE STANDARDS
• Branch naming:
  - feature/mrx/{project}/{short-desc}/{timestamp}
  - fix/mrx/{project}/{issue-id}/{timestamp}
  - mrx/update/{project}/{taskType}/{timestamp}
• Repo layout:
  - /app/src/main/java/...
  - /app/src/main/res/layout/...
  - /gradle/...
  - /build.gradle.kts (or build.gradle)
  - /mrx-config.json (project metadata: packageName, sdk versions, default build variants)
• Artifact naming:
  - MrX App Builder / {ProjectName} / {ProjectName}-{branch}-{buildNumber}-{yyyyMMddHHmm}.apk

KV KEY SCHEMA (GUIDELINES & EXAMPLES)
Use stable, human-readable key patterns to ease debugging and pagination.
• project:{projectId}:meta -> JSON {name, repoUrl, defaultBranch, driveFolderId}
• project:{projectId}:chat:{chatId}:messages -> list or chunked segments
• project:{projectId}:job:{jobId} -> {type, state, createdAt, claimedBy, result}
• project:{projectId}:faiss:manifest -> metadata about faiss index version, chunkCounts, lastUpdated
• project:{projectId}:logs:{jobId}:segment:{n} -> textual chunk (supports streaming)
• secret:github:{projectId} -> encrypted PAT (admin-only readable by backend; Colab reads via secure admin handshake)
• artifact:{projectId}:{buildId} -> {drivePath, size, sha256, uploadedAt}

API CONTRACTS & ENDPOINTS (Core)
Note: all APIs validate origin and require short-lived session tokens.
• GET /projects -> list projects user can access
• GET /projects/{id} -> project metadata
• GET /projects/{id}/chats -> list chats
• POST /projects/{id}/chats -> create chat (body: title, initialMessage)
• POST /projects/{id}/chats/{chatId}/messages -> append message & create job
• POST /jobs/create -> create build/patch job (request: jobType, payload)
• POST /jobs/claim -> Colab polls to claim job (colabId, secretKey)
• PATCH /jobs/{jobId} -> update job state (claimed, running, failed, completed)
• GET /jobs/{jobId}/logs?cursor= -> stream paginated logs
• GET /projects/{id}/artifacts -> list indexed APKs
• POST /admin/secrets -> admin-only; store encrypted secrets

SECURITY & CREDENTIAL HANDLING
• Frontend stores no secrets. Authentication is session tokenized; token has minimal scope and limited TTL.  
• Secrets live encrypted in KV and are accessible only to backend (for admin ops) and to Colab via an ephemeral secure handshake. The handshake uses a rotating claim token generated by the backend per Colab session. Colab stores credentials strictly in runtime memory/environment variables (not persisted).  
• All network traffic uses HTTPS and strict CORS allowlists. Backend validates origin, session, and job authenticity.  
• Audit log: every claim, push, build, and upload writes an append-only entry to KV logs for traceability.  
• LLM keys: users may supply OpenAI keys optionally for LLM mode; keys are only used by Colab and never stored in frontend. Prefer custom LLM endpoints with full auth header.

RETRIEVAL-AUGMENTED PRINCIPLES
• Chunking: Tree-Sitter-derived logical chunks (functions, classes, XML views) with metadata (path, startLine, endLine, nodeType).  
• Embedding: local models only (MiniLM-L6, BGE variants, MPNet, Instructor-large). Models selection is configurable per project.  
• Indexing: FAISS index per project, persisted in Colab session storage and mirrored metadata to KV (manifest). Colab rebuilds or incrementally updates indexes when commits change.  
• Prompt assembly: Always include only top-K relevant chunks (with path, snippet, and small surrounding context). Never send entire files. Include chat history summary and system instructions (max token budget).  
• Retrieval caching: store last-query vectors + result hashes to reduce recomputation.

OPERATIONAL LOGIC & JOB LIFECYCLE
• Job creation: backend creates immutable job record and writes initial logs segments.  
• Job claiming: Colab polls /jobs/claim and uses claim token to acquire exclusive ownership. Backend marks job as claimed and sets expiry (claim TTL).  
• Execution: Colab runs tasks (retrieve repo, update FAISS, retrieval, LLM call, generate patch, commit, build). Progress updates are appended to logs in KV in chunks.  
• Retry policy: for transient failures (network, build), automatic retry up to 3 attempts with exponential backoff; persistent failures require user intervention.  
• Cleanup: temporary branches are named and auto-closed after merge or after TTL (e.g., 14 days) unless flagged. FAISS snapshots older than X versions cleaned to preserve KV space.

ERROR HANDLING & OBSERVABILITY
• Every step appends structured log lines (timestamp, level, component, message, meta).  
• Logs chunked to enable streaming; frontend polls with cursor.  
• Health endpoints for Colab agents and backend show lastSeen, queueLength, and indexStatus.

DEVELOPER CHECKLIST (MINIMUM)
• Ensure Colab notebooks contain code to: clone repo, run Tree-Sitter chunker, run embedding model, build/maintain FAISS, assemble prompts, call LLM, apply unified diffs, push branches, run Gradle, upload APKs to Drive, write logs to KV.  
• Backend functions must validate payloads, maintain atomic job creation, encrypt secrets, and support claim endpoints.  
• Frontend must be stateless, render streaming logs, present diff viewer, and never store credentials.  
• Implement admin tooling for secret rotation, KV cleanup, and artifact indexing.

EXAMPLE JSON SNIPPETS (JOB)
job = {
  "id": "job_20251122_0001",
  "projectId": "mrx-weather",
  "type": "build-and-patch",
  "state": "pending",
  "payload": {"branch": "feature/mrx/weather-ui/20251122", "patchRequest": "..."},
  "createdAt": "2025-11-22T10:00:00Z",
  "logsCursor": 0
}

CONCLUDING NOTES
This universal specification provides the structural and operational rules to implement MrX App Builder Platform in a reproducible, free-first manner. It balances retrieval-first semantics, local embeddings + FAISS, and serverless orchestration to allow safe, auditable, and scalable Android development assisted by AI, while keeping user-facing surfaces free of secrets and focused on developer productivity.