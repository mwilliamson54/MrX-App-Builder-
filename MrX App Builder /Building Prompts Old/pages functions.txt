MrX App Builder Platform — CLOUDFLARE PAGES FUNCTIONS BACKEND SPECIFICATION
(Expanded Developer Blueprint — APIs, Data Models, Procedures, Security, Job System)

PURPOSE
The Cloudflare Pages Functions Backend is the coordination layer of the MrX App Builder Platform. It acts as the command router, metadata manager, job scheduler, log streaming engine, secret vault, and communication bridge between the Dashboard (frontend) and the Colab Heavy Agent (compute environment). It controls all CRUD operations for chats, projects, messages, and jobs, while preserving strict free-tier constraints, zero-secret exposure on the frontend, and robust cross-agent synchronization.

HIGH-LEVEL RESPONSIBILITIES
• Provide REST API endpoints consumed by the dashboard and Colab agent.  
• Manage Workers KV schemas for projects, chats, jobs, messages, logs, artifacts, and secrets.  
• Handle job scheduling, job claiming, lifecycle updates, and error state management.  
• Proxy GitHub project enumeration without exposing secrets.  
• Maintain secure channels for secrets retrieval by Colab (admin-only).  
• Validate all request origins, session tokens, and method signatures.  
• Transform user actions into reproducible job payloads executable by Colab.  
• Stream logs and artifacts metadata to dashboard.  
• Ensure complete data integrity and prevent duplication.

FREE-FIRST PRINCIPLES (BACKEND-SPECIFIC)
• Use Cloudflare Pages Functions (0 cost) for serverless endpoints.  
• Use Workers KV for metadata (small size, low-latency reads).  
• No external DBs — no Postgres, Mongo, Qdrant, Pinecone, etc.  
• No long-running compute or background daemons — Colab polls for jobs.  
• Keep backend operations lightweight, mostly key/value read–write cycles.

DATA MODELS & KV SCHEMA
1. PROJECT METADATA  
project:{projectId}:meta → {
  "projectId": "mrx-weather",
  "repo": "github.com/org/mrx-weather",
  "defaultBranch": "main",
  "createdAt": "...",
  "updatedAt": "..."
}

2. CHAT METADATA  
project:{projectId}:chat:{chatId}:meta → {
  "chatId": "...",
  "title": "UI rewrite",
  "createdAt": "...",
  "updatedAt": "...",
  "llmMode": "custom|openai"
}

3. CHAT MESSAGES (chunked)  
project:{projectId}:chat:{chatId}:messages:{segment} → message array segment

4. JOB OBJECT  
project:{projectId}:job:{jobId} → {
  "jobId": "...",
  "type": "chat|patch|build|index-rebuild",
  "state": "pending|claimed|running|failed|completed",
  "payload": {...},
  "claimedBy": null|"colab-agent-1",
  "createdAt": "...",
  "updatedAt": "..."
}

5. JOB LOGS  
project:{projectId}:logs:{jobId}:segment:{n} → log chunk

6. ARTIFACT INDEX  
project:{projectId}:artifacts → [
  {
    "artifactId": "...",
    "drivePath": "...",
    "sha256": "...",
    "buildNumber": "...",
    "uploadedAt": "..."
  }
]

7. SECRETS (ENCRYPTED)  
secret:github:{projectId}  
secret:drive:{projectId}  
secret:llm:{projectId}  
These are never accessible to frontend, only admin endpoints + Colab handshake.

API ENDPOINTS (FULL EXPLANATION)
1. GET /projects  
Returns list of all project metadata. Backend reads project:* keys from KV or queries GitHub repos and derives projectIds from naming patterns (mrx-*). No secrets returned.

2. GET /projects/{projectId}  
Fetch project metadata. Used by dashboard to populate UI.

3. GET /projects/{projectId}/chats  
List all chats for a given project, sorted by updatedAt.

4. POST /projects/{projectId}/chats  
Create a new chat. Backend creates:
• meta record  
• first message segment  
• initial job for chat-generation (if first message is included)

5. GET /projects/{projectId}/chats/{chatId}/messages  
Retrieve message history in paginated form.

6. POST /projects/{projectId}/chats/{chatId}/messages  
Append a new message to chat. Automatically triggers a "chat-generation" job in KV.

7. POST /jobs/create  
Used for manually triggered build or patch operations. Payload includes:
{
  "projectId": "...",
  "jobType": "build|patch",
  "payload": {...}
}

8. POST /jobs/claim  
Called only by Colab agents. Requires:
{
  "colabId": "...",
  "claimSecret": "one-time-secret"
}
Backend returns the oldest pending job or null. Marks job as claimed.

9. PATCH /jobs/{jobId}  
Colab updates job state:
{
  "state": "running|failed|completed",
  "progress": "string",
  "payloadDelta": {...}
}

10. GET /jobs/{jobId}/logs?cursor=n  
Dashboard polls for log segments. Backend returns any available segments after cursor.

11. GET /projects/{projectId}/artifacts  
Returns indexed artifacts from Google Drive metadata.

12. POST /admin/secrets  
Admin-only (backend-protected). Stores encrypted GitHub/Drive/LLM keys in KV.

13. GET /admin/secrets/{projectId}  
Admin-only. Used by backend → Colab handshake.

PROJECT ENUMERATION VIA GITHUB
Backend fetches repository list with a GitHub PAT stored in KV and filtered by prefix mrx-.  
Returned to dashboard as project list but secrets remain hidden.

JOB SCHEDULING LIFECYCLE
1. Dashboard creates job (messages, patches, builds).  
2. Backend inserts job with state = "pending".  
3. Colab periodically hits /jobs/claim.  
4. Backend returns next pending job with exclusive claim.  
5. Colab sets job state = "running" and appends logs to KV.  
6. Upon completion, state = "completed" + update artifacts.  
7. Dashboard polls job logs until finished.

LOG STREAMING PROTOCOL
• Collected in segments: logs:{jobId}:segment:{n}.  
• New segment appended whenever Colab flushes stdout/stderr chunk.  
• Cursor-based pagination: dashboard stores cursor and requests new segments every 2–4 seconds.  
• Segments are small to reduce KV write latency.

ARTIFACT INDEXING
After Colab uploads an APK, it posts metadata to backend:
{
  "artifactId": "...",
  "drivePath": "...",
  "sha256": "...",
  "uploadedAt": "..."
}
Backend appends to project’s artifact index list in KV.

SECRET-HANDLING MODEL
Frontend must NEVER see secrets.  
Backend stores encrypted values.  
Colab retrieves via admin endpoints using one-time claim token:
• token generated by backend  
• usable only once  
• short TTL (1–5 minutes)  
• revocation on claimComplete

CORS & SECURITY
• Only dashboard domain allowed via tight CORS policy.  
• All APIs require session token or agent claim secret.  
• Sensitive endpoints restricted to admin role or Colab agent.  
• Logs returned without sensitive tokens.

ERROR HANDLING
• All endpoints return structured errors:
{ "error": true, "code": "...", "message": "...", "details": {...} }  
• Jobs stuck in "running" for too long → timed out and marked failed.  
• Orphan logs cleaned after TTL.

DEVELOPER CHECKLIST
• Implement atomic KV writes for chat and job creation.  
• Prevent race conditions for job claims.  
• Maintain reliable pagination cursor for logs/messages.  
• Enforce strict type checking for payloads.  
• Encrypt secrets using Cloudflare’s built-in crypto API.  
• Keep all data structures minimal (KV size limits).  
• Add debug endpoints for project listing, KV stats, and health checks.

CONCLUSION
The Cloudflare Pages Functions Backend is the glue of the MrX App Builder ecosystem. It manages all public APIs, job scheduling, KV data orchestration, secrets, logs, and project metadata while remaining a fully free-tier, scalable, serverless platform. Its design ensures all heavy lifting is safely delegated to Colab while the dashboard remains lightweight, responsive, and secure. This layer guarantees reliable coordination in a multi-agent, multi-project Android development environment.